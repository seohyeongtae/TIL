## [R 데이터 온라인 교재 링크](https://thebook.io/006723/) - 더 자세한 설명있음

## R 1일차



AWS(아마존웹서비스) 에  CENTOS LINUX 환경 구축

R은 통계학적 접근이 많다.  - 마케팅/리서치에서 많이 사용한다.



###  R이란

> 빅데이터는 보통  3V로 정의된다. (규모 , 속도 , 다양성)
>
> R은 통계 분석에 특화된 언어이다. 통계 분석을 위한 프로그래밍 언어



### R설치 교재 24p~

[설치링크](https://ftp.harukasan.org/CRAN/) - R 

[R Studio](https://rstudio.com/products/rstudio/download/) - R 스튜디오를 사용하여 개발을 진행한다. (R을 편리하게 사용할 수 있도록 돕는 통합 개발 환경)

### R 사용

> Linux 와 비슷한 점이 많다. 

```R
> x <- 1+10
> x
[1] 11
> 
```



JDK 같은 경우 libs 을 다운받아서 넣었지만  R 같은 경우  Rstudio 내부에서 설치를 해야 한다.

(Packages 에서)

자바 Maven 과 같이 문제가 생길경우 받은 lib 을 삭제한 뒤 다시 받아야 한다. C드라이브  프로그램 파일 R 폴더 library 에 저장된다.



- Tools -> global option 에서 시작 폴더를 설정할 수 있다. 
- Tools -> global option ->code saving 에서 UFT-8 로 언어설정 변경 (기본 ask로 되어있다.)
- Appearance -> chaos 는 흑백화면
- 자바와 같이 R script 생성을 통해 코드들 작성 코드 실행은 Sql과 똑같다 ctrl + enter
- 모든 코드 실행은 ctrl + alt + r /  마지막 실행 코드 다시실행 ctrl+ shift + p



### 데이터 분석 과정

> 데이터 분석 설계 -> 데이터 준비 -> 데이터 가공 -> 데이터 분석 -> 결론 도출

- 데이터 분석 설계 : 방향성 기획 / 방법론 검토 / 가설 설정
- 데이터 준비 : 데이터 불러오기 / 형태 파악하기
- 데이터 가공 : 추출 및 정제 / 파생 변수 생성 / 데이터 병합
- 데이터 분석 : 통계 분석 / 그래프 및 시각화
- 결론 도출 : 분석 결과 해석 / 분석 결과 정리 



### R 변수 / 함수

> c() 함수 c는 combine(합치다)의 약어로 데이터 값 여러 개를 변수로 구성할 때 사용. c는 반드시 소문자
>
> :(콜론) 시작 숫자와 마지막 숫자 사이의 1씩 증가하는 연속 값을 변수로 구성
>
> seq() 함수 sequnece(연속)의 약오러 연속 값을 변수로 구성. by=4 와 같은 옵션을 추가하면 일정한 간격의 연속된 숫자로 구성된 변수 생성 가능

* 패키지 사용하기

```R
> install.packages("randomForest")

> library(help=“randomForest”)

> library(randomForest)
randomForest 4.6-7
Type rfNews() to see new features/changes/bug fixes.
```



> R 변수 

- 스칼라 (1차원 변수) : 스칼라란 단일 차원의 값을 뜻하는 것으로 숫자 1, 2, 3, …을 예로 들 수 있다. 반면 좌표 평면 위에 있는 점인 (1, 2)는 2차원 값이므로 이 절에서 설명하는 스칼라에 해당하지 않는다.

   따라서 스칼라 데이터는 길이가 1인 벡터(즉, 길이가 1인 배열)와 같은 것으로 볼 수 있다.

  * NA :  R과 다른 언어의 가장 큰 차이 중 하나가 바로 NA(Not Available) 상수다. NA는 데이터 값이 없음을 뜻한다

  * 변수에 NA 값이 저장되어 있는지는 is.na( ) 함수로 확인한다.

    ```R
    > one <- 80
    > two <- 90
    > three <- 75
    > four <- NA
    
    
    is.na(
       x # R의 데이터 객체 
    )
    # NA가 저장되어 있으면 TRUE, 그렇지 않으면 FALSE를 반환한다.
    
    > is.na(four)
    [1] TRUE
    ```

  * NULL : NULL은 NULL 객체를 뜻하며, 변수가 초기화되지 않았을 때 사용한다. NULL은 NA와 구분해서 생각해야 한다. 어떤 변수에 NULL이 저장되어 있는지는 is.null( )을 사용해 판단할 수 있다.

  ```R
  <Note> NULL과 NA의 차이
  NA는 결측치, 즉 값이 빠져 있는 경우를 뜻한다. 결측치가 존재하는 이유로는 데이터 입력 중 실수로 값을 입력하지 않은 경우, 값을 어떤 이유로든 관찰되지 못한 경우(예를 들어, 인구 조사에서 특정 가구가 소득을 기재하지 않은 경우), 마지막으로 해당 항목에 적절한 값이 없어서 값이 입력되지 않은 경우(예를 들어, 약품의 냄새를 기록하고 있는 칸에서 특정 약품은 향이 없는 경우)를 들 수 있다.
  
  반면 NULL은 프로그래밍의 편의를 위해 미정(undefined) 값을 표현하는 데 사용하는 개념이다. is_even이라는 변수에 a 변수의 값이 짝수면 TRUE, 홀수면 FALSE를 저장하는 다음 예를 보자.
  
    is_even <- NULL
    if (a 가 짝수면) {
       is_even <- TRUE
    } else {
       is_even <- FALSE
    }
  위 코드에서 if 조건문이 실행되기 전에는 is_even에 어떤 값을 줘야 할지 알 수 없어 NULL로 초기화했다. 그리고 if 문을 지나면서 is_even에 적절한 값이 할당되었다. 이처럼 NULL은 변숫값이 아직 미정인 상태를 표현하는 목적으로 사용한다.
  ```

  * 문자열 : R에는 C 등의 언어에서 볼 수 있는 한 개 문자에 대한 데이터 타입(예를 들면, C의 char 데이터 타입)이 없다. 대신 문자열로 모든 것을 표현한다. 문자열은 ‘this_is_string’ 또는 “this_is_string”과 같이 어느 따옴표로 묶어도 무관하다.

  ```R
  > a <- "hello"
  > print(a)
  [1] "hello"
  > a <- 'hello'
  > print(a)
  [1] "hello"
  ```

  * 진릿값 : TRUE, T는 모두 참 값을 의미한다. FALSE, F는 거짓 값을 의미한다. 진릿값에는 &(AND), |(OR), !(NOT) 연산자를 사용할 수 있다.

  * 팩터 : 팩터Factor는 범주형Categorical 데이터(자료)를 표현하기 위한 데이터 타입이다.

    https://thebook.io/006723/ch02/03/06/

    

- 벡터 ( 배열) : R에서 데이터 타입의 기본 / 벡터Vector는 다른 프로그래밍 언어에서 흔히 접하는 배열의 개념으로, 한 가지 스칼라 데이터 타입의 데이터를 저장할 수 있다. 예를 들어, 숫자만 저장하는 배열, 문자열만 저장하는 배열이 벡터에 해당한다.

  R의 벡터는 슬라이스Slice를 제공한다. 슬라이스란 배열의 일부를 잘라낸 뒤 이를 또 다시 배열처럼 다루는 개념을 뜻한다.

  또한, 벡터의 각 셀에는 이름을 부여할 수 있다. 따라서 벡터에 저장된 요소들을 색인을 사용하여 접근하는 것뿐 아니라 이름을 사용해서도 접근할 수 있다. 이런 특징을 사용하면 데이터를 좀 더 의미 있는 형태로 저장할 수 있다.

  ```R
  벡터는 c( )를 사용해 생성하고, names( )를 사용해 이름을 부여할 수 있다. 아래에 벡터 관련 함수를 정리했다.
  
  c : 주어진 값들을 모아 벡터를 생성한다
  c(
     ...  # 벡터로 모을 R 객체들
  )
  반환 값은 벡터다.
  
  
  names : 객체의 이름을 반환한다.
  names(
     x  # 이름을 얻어올 R 객체 
  )
  반환 값은 x와 같은 길이의 문자열 벡터 또는 NULL이다.
  
  names<- : 객체에 이름을 저장한다.2
  names(
     x          # 이름을 저장할 R 객체 
  ) <- value # 저장할 이름
  
  여러 위치에 저장된 값을 한 번에 가져오려면 ‘벡터명[색인 벡터]’ 형식을 사용한다.
  a <- factor("A",c("A","B","C"))
  a
  v1 <- c(1,2,3)
  names(v1) <- c("d1","d2","d3")
  v1[c(1,3)]       # = v1[-2]
  v1[c("d1","d3")]
  v1["d2"]
  
  length(v1)
  NROW(v1)
  names(v1)
  names(v1)[c(2,3)]
  
  
  union(
     x,  # 벡터 
     y   # 벡터 
  )
  identical : 객체가 동일한지를 판단한다.
  union : 합집합을 구한다.
  intersect : 교집합을 구한다.
  setdiff : 차집합을 구한다.
  setequal : x와 y가 같은 집합인지 판단한다.
  
  value %in% x   #벡터 x에 value가 저장되어 있는지 판단함
  x + n   # 벡터 x의 모든 요소에 n을 더한 벡터를 구함. 마찬가지로 *, /, -, == 등의 연산자를 적용 가능함
  v2 <- v1 +10
  v2 <- v1 + v1
  
  
  
  
  seq : 시퀀스를 생성한다.
  seq(
    from,  # 시작 값 
    to,    # 끝 값 
    by     # 증가치 
  )
  from부터 to까지의 값을 by 간격으로 저장한 숫자 벡터를 반환한다.
  seq(from, end, by)는 from부터 end까지의 값을 저장한 벡터를 반환한다. 여기서 by는 생략 가능하며, 이 경우 1씩 증가 또는 감소하는 것으로 자동 지정된다. 다음에 몇 가지 사용 예를 보였다.
  
  seq_along : 주어진 객체의 길이만큼 시퀀스를 생성한다.
  seq_along(
    along.with  # 이 인자 길이만큼 시퀀스를 생성한다. 
  )
  반환 값은 along.with의 길이가 N일 때, 1부터 N까지의 숫자를 저장한 벡터다.
  
  1씩 증가 또는 감소하는 벡터의 경우 seq( )를 사용하지 않고 ‘start:end’ 형태의 축약형으로도 표현할 수 있다.
  > 3:7
  [1] 3 4 5 6 7
  
  
  
  rep : 주어진 값을 반복한다.
  rep(
     x,      # 반복할 값이 저장된 벡터 
     times,  # 전체 벡터의 반복 횟수 
     each    # 개별 값의 반복 횟수 
  )
  반환 값은 반복된 값이 저장된 x와 같은 타입의 객체다.
  
  > rep(1:2, times=5)
  [1] 1 2 1 2 1 2 1 2 1 2
  
  > rep(1:2, each=5)
  [1] 1 1 1 1 1 2 2 2 2 2
  
  > rep(1:2, each=5, times=2)
  [1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2
  ```

  

- 리스트<k,v> :  자료 구조 책에서 리스트List는 배열과 비교할 때 데이터를 중간 중간에 삽입하는 데 유리한 구조로 설명한다. 물론 그러한 장점은 동일하지만 R에서 리스트는 데이터를 접근한다는 관점에서 다른 언어의 해시 테이블 또는 딕셔너리로 종종 설명된다. 즉, 리스트는 ‘(키, 값)’ 형태의 데이터를 담는 연관 배열Associative Array이다.

  또 다른 리스트의 특징은 벡터와 달리 값이 서로 다른 데이터 타입을 담을 수 있다는 점이다. 따라서 “이름”이라는 키에 “홍길동”이라는 문자열 값을 저장하고, “성적”이라는 키에 95라는 숫자 값을 저장할 수 있다.

  ```R
  
  list : 리스트 객체를 생성한다.
  
  list(
     key1=value1, 
     key2=value2, 
     ... 
  )
  반환 값은 key1에 value1, key2에 value2 등을 저장한 리스트다.
  
  > (x <- list(name="foo", height=70))
  $ name
  [1] "foo"
  
  $ height
  [1] 70
  
  list1 <- list(v1 = "data1", v2 = "data2")
  list1$v1
  
  > list (a=list(val=c(1, 2, 3)), b=list(val=c(1, 2, 3, 4)))
  $a
  $a$val
  [1] 1 2 3
  
  $b
  $b$val
  [1] 1 2 3 4
  
  
  x$key 	 #리스트 x에서 키 값 key에 해당하는 값
  x[n]  	 #리스트 x에서 n번째 데이터의 서브리스트
  x		 #리스트 x에서 n번째 저장된 값
  > x <- list(name="foo", height=c(1, 3, 5))
  > x$name
  [1] "foo"
  > x$height
  [1] 1 3 5
  > x1
  [1] "foo"
  > x2
  [1] 1 3 5
  
  ```

  

- 행렬 (동일 타입의 매트릭스) : R의 행렬Matrix은 수학 시간에 배운 행렬의 정의와 같이 행(로우), 열(컬럼)의 수가 지정된 구조다. 벡터와 마찬가지로 행렬에는 한 가지 유형의 스칼라만 저장할 수 있다. 따라서 모든 요소가 숫자인 행렬은 가능하지만, ‘1열은 숫자, 2열은 문자열’과 같은 형태는 불가능하다.

  ```R
  
  matrix : 행렬을 생성한다.
  matrix( 
     data,          # 행렬을 생성할 데이터 벡터 
     nrow,          # 행의 수 
     ncol,          # 열의 수 
     byrow=FALSE,   # TRUE로 설정하면 행우선, FALSE일 경우 열 우선으로 데이터를 채운다. 
     dimnames=NULL  # 행렬의 각 차원에 부여할 이름 
  )
  반환 값은 행렬이다.
  
  dimnames : 객체의 각 차원에 대한 이름을 가져온다.
  dimnames<- : 객체의 차원에 이름을 설정한다.
  rownames : 행렬의 행 이름을 가져온다.
  rownames<- : 행렬의 행 이름을 설정한다.
  colnames : 행렬의 열 이름을 가져온다.
  colnames<- : 행렬의 열 이름을 설정한다.
  
  
  행렬은 matrix( )를 사용해 표현한다. 다음은 1, 2, 3, 4, 5, 6, 7, 8, 9로 구성된 3×3(3행 3열) 행렬을 만드는 방법을 보여준다.
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3)
       [,1] [,2] [,3]
  [1,]    1    4    7
  [2,]    2    5    8
  [3,]    3    6    9
  
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol=3)
      [,1] [,2] [,3]
  [1,]   1    4    7
  [2,]   2    5    8
  [3,]   3    6    9
  
  
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3, byrow=TRUE)
       [,1] [,2] [,3]
  [1,]    1    2    3
  [2,]    4    5    6
  [3,]    7    8    9
  
  
  > matrix(1:9, nrow=3,
          dimnames=list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
     c1 c2 c3
  r1  1  4  7
  r2  2  5  8
  r3  3  6  9
  # 위의 결과 동일하게 나옴
  m1 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3)
  m1
  colnames(m1) <- c("c1","c2","c3")
  rownames(m1) <- c("R1","R2","R3")
  m1
  
  A[ridx, cidx] 행렬 A의 ridx행, cidx열에 저장된 값. 이때 ridx나 cidx에 벡터를 사용해 여러 값을 지정가능함. ridx나 cidx 중 하나를 생략하면 전체 행 또는 열을 의미함
  
  > x[1,1]
  > x[1:2, ]
  > x[-3, ]
  > x[c(1, 3), c(1, 3)]
  > x["r1", ]
  
  
  
  
  A + x	#행렬 A의 모든 값에 스칼라 x를 더한다. 이외에도 -, *, / 연산자를 사용할 수 있다
  A + B	#행렬 A와 행렬 B의 합을 구한다. 행렬 간의 차는 - 연산자를 사용한다.
  A %*% B	#행렬 A와 행렬 B의 곱을 구한다
  
  t : 행렬 또는 데이터 프레임의 전치 행렬을 구한다.
  solve : 수식 a %*% x = b에서 x를 구한다.
  nrow : 배열의 행의 수를 구한다.
  ncol : 배열의 열의 수를 구한다.
  dim : 객체의 차원 수를 구한다.
  dim<- : 객체의 차원 수를 지정한다.
  
  ```

  

- 배열

- 데이터 프레임

  

