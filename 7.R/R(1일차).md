## [R 데이터 온라인 교재 링크](https://thebook.io/006723/) - 더 자세한 설명있음

[교재 깃허브 데이터저장소 링크](https://github.com/newstars/HelloR)

## R 1일차



AWS(아마존웹서비스) 에  CENTOS LINUX 환경 구축

R은 통계학적 접근이 많다.  - 마케팅/리서치에서 많이 사용한다.



###  R이란

> 빅데이터는 보통  3V로 정의된다. (규모 , 속도 , 다양성)
>
> R은 통계 분석에 특화된 언어이다. 통계 분석을 위한 프로그래밍 언어



### R설치 교재 24p~

[설치링크](https://ftp.harukasan.org/CRAN/) - R 

[R Studio](https://rstudio.com/products/rstudio/download/) - R 스튜디오를 사용하여 개발을 진행한다. (R을 편리하게 사용할 수 있도록 돕는 통합 개발 환경)

### R 사용

> Linux 와 비슷한 점이 많다. 

```R
> x <- 1+10
> x
[1] 11
> 
```



JDK 같은 경우 libs 을 다운받아서 넣었지만  R 같은 경우  Rstudio 내부에서 설치를 해야 한다.

(Packages 에서)

자바 Maven 과 같이 문제가 생길경우 받은 lib 을 삭제한 뒤 다시 받아야 한다. C드라이브  프로그램 파일 R 폴더 library 에 저장된다.



- Tools -> global option 에서 시작 폴더를 설정할 수 있다. 
- Tools -> global option ->code saving 에서 UFT-8 로 언어설정 변경 (기본 ask로 되어있다.)
- Appearance -> chaos 는 흑백화면
- 자바와 같이 R script 생성을 통해 코드들 작성 코드 실행은 Sql과 똑같다 ctrl + enter
- 모든 코드 실행은 ctrl + alt + r /  마지막 실행 코드 다시실행 ctrl+ shift + p



### 데이터 분석 과정

> 데이터 분석 설계 -> 데이터 준비 -> 데이터 가공 -> 데이터 분석 -> 결론 도출

- 데이터 분석 설계 : 방향성 기획 / 방법론 검토 / 가설 설정
- 데이터 준비 : 데이터 불러오기 / 형태 파악하기
- 데이터 가공 : 추출 및 정제 / 파생 변수 생성 / 데이터 병합
- 데이터 분석 : 통계 분석 / 그래프 및 시각화
- 결론 도출 : 분석 결과 해석 / 분석 결과 정리 



### R 변수 / 함수

> c() 함수 c는 combine(합치다)의 약어로 데이터 값 여러 개를 변수로 구성할 때 사용. c는 반드시 소문자
>
> :(콜론) 시작 숫자와 마지막 숫자 사이의 1씩 증가하는 연속 값을 변수로 구성
>
> seq() 함수 sequnece(연속)의 약오러 연속 값을 변수로 구성. by=4 와 같은 옵션을 추가하면 일정한 간격의 연속된 숫자로 구성된 변수 생성 가능

* 패키지 사용하기

```R
> install.packages("randomForest")

> library(help=“randomForest”)

> library(randomForest)
randomForest 4.6-7
Type rfNews() to see new features/changes/bug fixes.
```



> R 변수 

- **스칼라** (1차원 변수) : 스칼라란 단일 차원의 값을 뜻하는 것으로 숫자 1, 2, 3, …을 예로 들 수 있다. 반면 좌표 평면 위에 있는 점인 (1, 2)는 2차원 값이므로 이 절에서 설명하는 스칼라에 해당하지 않는다.

   따라서 스칼라 데이터는 길이가 1인 벡터(즉, 길이가 1인 배열)와 같은 것으로 볼 수 있다.

  * NA :  R과 다른 언어의 가장 큰 차이 중 하나가 바로 NA(Not Available) 상수다. NA는 데이터 값이 없음을 뜻한다

  * 변수에 NA 값이 저장되어 있는지는 is.na( ) 함수로 확인한다.

    ```R
    > one <- 80
    > two <- 90
    > three <- 75
    > four <- NA
    
    
    is.na(
       x # R의 데이터 객체 
    )
    # NA가 저장되어 있으면 TRUE, 그렇지 않으면 FALSE를 반환한다.
    
    > is.na(four)
    [1] TRUE
    ```

  * NULL : NULL은 NULL 객체를 뜻하며, 변수가 초기화되지 않았을 때 사용한다. NULL은 NA와 구분해서 생각해야 한다. 어떤 변수에 NULL이 저장되어 있는지는 is.null( )을 사용해 판단할 수 있다.

  ```R
  <Note> NULL과 NA의 차이
  NA는 결측치, 즉 값이 빠져 있는 경우를 뜻한다. 결측치가 존재하는 이유로는 데이터 입력 중 실수로 값을 입력하지 않은 경우, 값을 어떤 이유로든 관찰되지 못한 경우(예를 들어, 인구 조사에서 특정 가구가 소득을 기재하지 않은 경우), 마지막으로 해당 항목에 적절한 값이 없어서 값이 입력되지 않은 경우(예를 들어, 약품의 냄새를 기록하고 있는 칸에서 특정 약품은 향이 없는 경우)를 들 수 있다.
  
  반면 NULL은 프로그래밍의 편의를 위해 미정(undefined) 값을 표현하는 데 사용하는 개념이다. is_even이라는 변수에 a 변수의 값이 짝수면 TRUE, 홀수면 FALSE를 저장하는 다음 예를 보자.
  
    is_even <- NULL
    if (a 가 짝수면) {
       is_even <- TRUE
    } else {
       is_even <- FALSE
    }
  위 코드에서 if 조건문이 실행되기 전에는 is_even에 어떤 값을 줘야 할지 알 수 없어 NULL로 초기화했다. 그리고 if 문을 지나면서 is_even에 적절한 값이 할당되었다. 이처럼 NULL은 변숫값이 아직 미정인 상태를 표현하는 목적으로 사용한다.
  ```

  * 문자열 : R에는 C 등의 언어에서 볼 수 있는 한 개 문자에 대한 데이터 타입(예를 들면, C의 char 데이터 타입)이 없다. 대신 문자열로 모든 것을 표현한다. 문자열은 ‘this_is_string’ 또는 “this_is_string”과 같이 어느 따옴표로 묶어도 무관하다.

  ```R
  > a <- "hello"
  > print(a)
  [1] "hello"
  > a <- 'hello'
  > print(a)
  [1] "hello"
  ```

  * 진릿값 : TRUE, T는 모두 참 값을 의미한다. FALSE, F는 거짓 값을 의미한다. 진릿값에는 &(AND), |(OR), !(NOT) 연산자를 사용할 수 있다.

  * 팩터 : 팩터Factor는 범주형Categorical 데이터(자료)를 표현하기 위한 데이터 타입이다.

    https://thebook.io/006723/ch02/03/06/

    

- **벡터 ( 배열)** : R에서 데이터 타입의 기본 / 벡터Vector는 다른 프로그래밍 언어에서 흔히 접하는 배열의 개념으로, 한 가지 스칼라 데이터 타입의 데이터를 저장할 수 있다. 예를 들어, 숫자만 저장하는 배열, 문자열만 저장하는 배열이 벡터에 해당한다.

  R의 벡터는 슬라이스Slice를 제공한다. 슬라이스란 배열의 일부를 잘라낸 뒤 이를 또 다시 배열처럼 다루는 개념을 뜻한다.

  또한, 벡터의 각 셀에는 이름을 부여할 수 있다. 따라서 벡터에 저장된 요소들을 색인을 사용하여 접근하는 것뿐 아니라 이름을 사용해서도 접근할 수 있다. 이런 특징을 사용하면 데이터를 좀 더 의미 있는 형태로 저장할 수 있다.

  ```R
  벡터는 c( )를 사용해 생성하고, names( )를 사용해 이름을 부여할 수 있다. 아래에 벡터 관련 함수를 정리했다.
  
  c : 주어진 값들을 모아 벡터를 생성한다
  c(
     ...  # 벡터로 모을 R 객체들
  )
  반환 값은 벡터다.
  
  remove(백터명) # 데이터 세트 삭제
  rm(백터명)
  
  names : 객체의 이름을 반환한다.
  names(
     x  # 이름을 얻어올 R 객체 
  )
  반환 값은 x와 같은 길이의 문자열 벡터 또는 NULL이다.
  
  names<- : 객체에 이름을 저장한다.2
  names(
     x          # 이름을 저장할 R 객체 
  ) <- value # 저장할 이름
  
  여러 위치에 저장된 값을 한 번에 가져오려면 ‘벡터명[색인 벡터]’ 형식을 사용한다.
  a <- factor("A",c("A","B","C"))
  a
  v1 <- c(1,2,3)
  names(v1) <- c("d1","d2","d3")
  v1[c(1,3)]       # = v1[-2]
  v1[c("d1","d3")]
  v1["d2"]
  
  length(v1)
  NROW(v1)
  names(v1)
  names(v1)[c(2,3)]
  
  
  union(
     x,  # 벡터 
     y   # 벡터 
  )
  identical : 객체가 동일한지를 판단한다.
  union : 합집합을 구한다.
  intersect : 교집합을 구한다.
  setdiff : 차집합을 구한다.
  setequal : x와 y가 같은 집합인지 판단한다.
  
  value %in% x   #벡터 x에 value가 저장되어 있는지 판단함
  x + n   # 벡터 x의 모든 요소에 n을 더한 벡터를 구함. 마찬가지로 *, /, -, == 등의 연산자를 적용 가능함
  v2 <- v1 +10
  v2 <- v1 + v1
  
  
  
  
  seq : 시퀀스를 생성한다.
  seq(
    from,  # 시작 값 
    to,    # 끝 값 
    by     # 증가치 
  )
  from부터 to까지의 값을 by 간격으로 저장한 숫자 벡터를 반환한다.
  seq(from, end, by)는 from부터 end까지의 값을 저장한 벡터를 반환한다. 여기서 by는 생략 가능하며, 이 경우 1씩 증가 또는 감소하는 것으로 자동 지정된다. 다음에 몇 가지 사용 예를 보였다.
  
  seq_along : 주어진 객체의 길이만큼 시퀀스를 생성한다.
  seq_along(
    along.with  # 이 인자 길이만큼 시퀀스를 생성한다. 
  )
  반환 값은 along.with의 길이가 N일 때, 1부터 N까지의 숫자를 저장한 벡터다.
  
  1씩 증가 또는 감소하는 벡터의 경우 seq( )를 사용하지 않고 ‘start:end’ 형태의 축약형으로도 표현할 수 있다.
  > 3:7
  [1] 3 4 5 6 7
  
  
  
  rep : 주어진 값을 반복한다.
  rep(
     x,      # 반복할 값이 저장된 벡터 
     times,  # 전체 벡터의 반복 횟수 
     each    # 개별 값의 반복 횟수 
  )
  반환 값은 반복된 값이 저장된 x와 같은 타입의 객체다.
  
  > rep(1:2, times=5)
  [1] 1 2 1 2 1 2 1 2 1 2
  
  > rep(1:2, each=5)
  [1] 1 1 1 1 1 2 2 2 2 2
  
  > rep(1:2, each=5, times=2)
  [1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2
  ```

  

- 리스트<k,v> :  자료 구조 책에서 리스트List는 배열과 비교할 때 데이터를 중간 중간에 삽입하는 데 유리한 구조로 설명한다. 물론 그러한 장점은 동일하지만 R에서 리스트는 데이터를 접근한다는 관점에서 다른 언어의 해시 테이블 또는 딕셔너리로 종종 설명된다. 즉, 리스트는 ‘(키, 값)’ 형태의 데이터를 담는 연관 배열Associative Array이다.

  또 다른 리스트의 특징은 벡터와 달리 값이 서로 다른 데이터 타입을 담을 수 있다는 점이다. 따라서 “이름”이라는 키에 “홍길동”이라는 문자열 값을 저장하고, “성적”이라는 키에 95라는 숫자 값을 저장할 수 있다.

  ```R
  
  list : 리스트 객체를 생성한다.
  
  list(
     key1=value1, 
     key2=value2, 
     ... 
  )
  반환 값은 key1에 value1, key2에 value2 등을 저장한 리스트다.
  
  > (x <- list(name="foo", height=70))
  $ name
  [1] "foo"
  
  $ height
  [1] 70
  
  list1 <- list(v1 = "data1", v2 = "data2")
  list1$v1
  
  > list (a=list(val=c(1, 2, 3)), b=list(val=c(1, 2, 3, 4)))
  $a
  $a$val
  [1] 1 2 3
  
  $b
  $b$val
  [1] 1 2 3 4
  
  
  x$key 	 #리스트 x에서 키 값 key에 해당하는 값
  x[n]  	 #리스트 x에서 n번째 데이터의 서브리스트
  x		 #리스트 x에서 n번째 저장된 값
  > x <- list(name="foo", height=c(1, 3, 5))
  > x$name
  [1] "foo"
  > x$height
  [1] 1 3 5
  > x1
  [1] "foo"
  > x2
  [1] 1 3 5
  
  ```

  

- 행렬 (동일 타입의 매트릭스) : R의 행렬Matrix은 수학 시간에 배운 행렬의 정의와 같이 행(로우), 열(컬럼)의 수가 지정된 구조다. 벡터와 마찬가지로 행렬에는 한 가지 유형의 스칼라만 저장할 수 있다. 따라서 모든 요소가 숫자인 행렬은 가능하지만, ‘1열은 숫자, 2열은 문자열’과 같은 형태는 불가능하다.

  ```R
  
  matrix : 행렬을 생성한다.
  matrix( 
     data,          # 행렬을 생성할 데이터 벡터 
     nrow,          # 행의 수 
     ncol,          # 열의 수 
     byrow=FALSE,   # TRUE로 설정하면 행우선, FALSE일 경우 열 우선으로 데이터를 채운다. 
     dimnames=NULL  # 행렬의 각 차원에 부여할 이름 
  )
  반환 값은 행렬이다.
  
  dimnames : 객체의 각 차원에 대한 이름을 가져온다.
  dimnames<- : 객체의 차원에 이름을 설정한다.
  rownames : 행렬의 행 이름을 가져온다.
  rownames<- : 행렬의 행 이름을 설정한다.
  colnames : 행렬의 열 이름을 가져온다.
  colnames<- : 행렬의 열 이름을 설정한다.
  
  
  행렬은 matrix( )를 사용해 표현한다. 다음은 1, 2, 3, 4, 5, 6, 7, 8, 9로 구성된 3×3(3행 3열) 행렬을 만드는 방법을 보여준다.
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3)
       [,1] [,2] [,3]
  [1,]    1    4    7
  [2,]    2    5    8
  [3,]    3    6    9
  
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), ncol=3)
      [,1] [,2] [,3]
  [1,]   1    4    7
  [2,]   2    5    8
  [3,]   3    6    9
  
  
  > matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3, byrow=TRUE)
       [,1] [,2] [,3]
  [1,]    1    2    3
  [2,]    4    5    6
  [3,]    7    8    9
  
  
  > matrix(1:9, nrow=3,
          dimnames=list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
     c1 c2 c3
  r1  1  4  7
  r2  2  5  8
  r3  3  6  9
  # 위의 결과 동일하게 나옴
  m1 <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow=3)
  m1
  colnames(m1) <- c("c1","c2","c3")
  rownames(m1) <- c("R1","R2","R3")
  m1
  
  A[ridx, cidx] 행렬 A의 ridx행, cidx열에 저장된 값. 이때 ridx나 cidx에 벡터를 사용해 여러 값을 지정가능함. ridx나 cidx 중 하나를 생략하면 전체 행 또는 열을 의미함
  
  > x[1,1]
  > x[1:2, ]
  > x[-3, ]
  > x[c(1, 3), c(1, 3)]
  > x["r1", ]
  > x[ ,"c1"]
  
  
  
  
  A + x	#행렬 A의 모든 값에 스칼라 x를 더한다. 이외에도 -, *, / 연산자를 사용할 수 있다
  A + B	#행렬 A와 행렬 B의 합을 구한다. 행렬 간의 차는 - 연산자를 사용한다.
  A %*% B	#행렬 A와 행렬 B의 곱을 구한다
  
  t : 행렬 또는 데이터 프레임의 전치 행렬을 구한다.
  solve : 수식 a %*% x = b에서 x를 구한다.
  nrow : 배열의 행의 수를 구한다.
  ncol : 배열의 열의 수를 구한다.
  dim : 객체의 차원 수를 구한다.
  dim<- : 객체의 차원 수를 지정한다.
  
  ```

  

- 배열 (다차원 행렬) : 행렬이 2차원 데이터라면 배열Array은 다차원 데이터다. 예를 들어, 2×3 차원의 데이터를 행렬로 표현한다면 2×3×4 차원의 데이터는 배열로 표현한다.

- **데이터 프레임**  (다중(데이터타입) 행렬): 데이터 프레임Data Frame은 처리할 데이터를 마치 엑셀의 스프레드시트와 같이 표 형태로 정리한 모습을 하고 있다. 데이터 프레임의 각 열에는 관측값의 이름이 저장되고, 각 행에는 매 관측 단위마다 실제 얻어진 값이 저장된다. 예를 들어, 다음 성적 데이터와 같은 모습이 데이터 프레임에 저장되는 데이터의 전형적인 예다.

  이처럼 자연스럽게 데이터를 표현하는 데이터 타입이기 때문에 데이터 프레임은 R에서 가장 중요한 데이터 타입이며, 많은 R 함수에서 인자로 데이터 프레임을 받는다.

  ```R
  
  d1 <- data.frame(name =c("kim","Lee","seo"),
                   ko=c(90,80,98),
                   ev =c(100,78,92),
                   ma = c(99,68,88))
  d1
  
  str : 임의의 R 객체의 내부 구조(structure)를 보인다.
  str(
     object # 구조를 살펴볼 R 객체
  )
  
  
  d$colname # 데이터 프레임 d에서 컬럼 이름이 colname인 데이터를 접근한다.
  d$colname <- y # 데이터 프레임 d에서 컬럼 이름이 colname인 컬럼에 데이터 y를 저장한다. 만약 colname이 d에 없는 새로운 이름이라면 새로운 컬럼이 추가된다.
  
  dname <- d1$name
  d1$ko <- c(100,90,99)
  d1$si <- c(90,88,80)	# 수정 및 추가도 자유롭게 할 수 있다.
  ```

  
  - 데이터 프레임 접근

    ```R
    d$colname  #데이터 프레임 d의 컬럼 이름 colname에 저장된 데이터
    d[m, n, drop=TRUE] #데이터 프레임 d의 m행 n 컬럼에 저장된 데이터.
    
    > d1[c(1, 3), 2]
    > d1[-1, -2]
    > d1[-1,c("ko","en","ma")]  # 구체적으로 컬럼명을 써주는 것이 좋다.
    
    > d1[, c("ko"), drop=FALSE]  # 형 변환을 원치 않는다면 다음과 같이 drop=FALSE 옵션을 지정한다. 원래 데이터 행/열(데이터프래임) 형식으로 출력 시키고 싶을때
    
    ```

  - 유틸리티 함수 : 데이터 프레임은 분석할 데이터가 들어 있는 주요 데이터 타입이다. 분석할 데이터는 보통 파일 등에서 불러들이므로, 불러들인 데이터가 올바른 데이터 타입으로 저장되어 있는지 확인하는 것이 중요하다. 또, 데이터 프레임에는 분석할 데이터 전체가 저장되므로 데이터양이 많다. 따라서 이러한 데이터를 손쉽게 살펴보는 방법이 필요하다. 이 절에서는 데이터 프레임과 관련하여 참고할 만한 함수들을 설명한다.

    ```R
    head : 객체의 처음 부분을 반환한다.
    > head(d1,1)
    
    tail : 객체의 뒷부분을 반환한다.
    View : 데이터 뷰어를 호출한다.
    ```

  - **타입판별** : 데이터를 처리하기 위해 여러 함수를 호출하다 보면 반환된 결과의 타입이 무엇인지 분명하지 않을 때가 많다. 이 경우 다음 함수들을 사용하여 데이터 타입을 손쉽게 판단할 수 있다.

    ```R
    typoeof()
    mode()
    
    class(x)
    
    객체 x의 클래스
    
    str(x)
    
    객체 x의 내부 구조
    
    is.factor(x)
    
    주어진 객체 x가 팩터인가
    
    is.numeric(x)
    
    주어진 객체 x가 숫자를 저장한 벡터인가
    
    is.character(x)
    
    주어진 객체 x가 문자열을 저장한 벡터인가
    
    is.matrix(x)
    
    주어진 객체 x가 행렬인가
    
    is.array(x)
    
    주어진 객체 x가 배열인가
    
    is.data.frame(x)
    
    주어진 객체 x가 데이터 프레임인가
    ```

  - **타입변환** : R의 형 변환은 암시적으로 발생할 수 있고, 때에 따라 형 변환이 전혀 예상치 않은 곳에서 일어난다. 예를 들어, 데이터 프레임 d에 2개 컬럼이 있고 각 컬럼의 데이터 타입이 numeric(숫자를 저장한 벡터)이라고 가정하자. **이때 d[, 1]은 첫 번째 컬럼의 데이터를 데이터 프레임이 아닌 numeric(즉, 벡터)으로 반환한다. d에 대한 연산의 결과가 데이터 프레임이 아니라 numeric이라는 점은 사용자를 당황하게 할 수 있는 점이며, 이러한 변환을 피하고 싶다면 drop=FALSE를 지정해야 한다. 또는 파일에서 문자열을 불러들였을 때 data.frame( )으로 데이터 프레임을 생성하면서 *stringsAsFactor=FALSE*를 지정하지 않으면 문자열이 character(문자열 벡터)가 아니라 팩터가 된다.**

    이와 같은 암시적 형 변환에 대비하기 위해 모든 의심스러운 함수 호출 뒤에는 ‘2.9 타입 판별’ 절에서 설명한 str( ), class( )를 사용해 현재 사용하는 데이터가 올바른 데이터 타입인지 계속 확인할 필요가 있다.

    반면 타입을 강제로 변환하고자 할 때도 있을 것이다. 문자열 벡터를 팩터로 변환하는 경우 등이 그 예다. 이러한 변환을 하는 한 가지 방법은 타입 이름이 ‘typename’이라 할 때 ‘as.typename( )’이라는 함수를 사용하는 것이다. 다음에 관련 함수의 목록을 보였다.

    ```R
    as.factor(x)
    
    주어진 객체 x를 팩터로 변환
    
    as.numeric(x)
    
    주어진 객체 x를 숫자를 저장한 벡터로 변환
    
    as.character(x)
    
    주어진 객체 x를 문자열을 저장한 벡터로 변환
    
    as.matrix(x)
    
    주어진 객체 x를 행렬로 변환
    
    as.array(x)
    
    주어진 객체 x를 배열로 변환
    
    as.data.frame(x)
    
    주어진 객체 x를 데이터 프레임으로 변환
    ```

### 엑셀 파일 불러오기

```R
install.packages("readxl")
library(readxl)
ex1 <- read_excel("C:/Users/i/Desktop/git hub/git hub/TIL/7.R/교재 데이터 저장소/HelloR/Data/data_ex.xls")
ex1
str(ex1)

ex1 <- read_excel("data_ex.xls")
# 같은 폴더 안에 있으면 파일명으로 불러올 수 있다.

```





